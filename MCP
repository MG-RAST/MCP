#!/usr/bin/env python

import inspect
import sys, shlex, socket
import getpass, commands, subprocess
import re
from ConfigParser import SafeConfigParser

__doc__ = """
MG-RAST Control Program (MCP)

SERVICE \tACTIONS\t\tUSER
"""

MCP_path = sys.argv[0]
matchObj = re.match(r'(^.*\/)', MCP_path)
MCP_dir = matchObj.group()

path = list(sys.path)
sys.path.insert(0, MCP_dir+'/modules')

parser = SafeConfigParser()
parser.read(MCP_dir+'conf/conf.ini')

service_action_to_req_user = {}

for module_name in parser.get('global', 'services').split(','):
    module_name = module_name.strip()
    module = __import__(module_name)
    for name, obj in inspect.getmembers(module):
        if inspect.isclass(obj) and hasattr(obj, 'actions'):
            userhost = ""
            if parser.has_option(module_name, 'user') and parser.has_option(module_name, 'host'):
                userhost = parser.get(module_name, 'user') + '@' + parser.get(module_name, 'host')
            for action in obj.actions.split(','):
                service_action_to_req_user[name + " " + action.strip()] = userhost

            __doc__ += name + "\t" + obj.actions + "   \t" + userhost + "\n"

# Run command subroutine
def run_cmd(cmd_str):
    print cmd_str
    cmd = shlex.split(str(cmd_str))
    proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        raise IOError("%s\n%s"%(" ".join(cmd), stderr))

    return stdout, stderr

def main(args):
    usage = "\nUsage: MCP service action\n" + __doc__

    # Checking number of inputs.
    if len(sys.argv) != 3:
        sys.stderr.write(usage)
        sys.stderr.write("\n")
    else:
        service = sys.argv[1]
        action = sys.argv[2]

        # Checking that user has entered a valid service-action pair.
        service_action = service + " " + action
        if service_action not in service_action_to_req_user:
            sys.stderr.write("\nERROR: service-action '" + service_action + "' not available\n" + usage)
            sys.stderr.write("\n")
            return 0

        # Checking that the command is being called by the correct user@hostname.  Otherwise, pass
        #   the command onto the appropriate machine as the appropriate user via ssh.  For the time
        #   being we're just going to call 'sudo -s', but this will change later.
        user = getpass.getuser()
        host = socket.gethostname()
        if service_action_to_req_user[service_action] != "" and (user + "@" + host) != service_action_to_req_user[service_action]:
            print "Handing off command to run as: " + service_action_to_req_user[service_action]
            array = commands.getstatusoutput("sudo -s ssh " + service_action_to_req_user[service_action] + " " + MCP_path + " " + service_action)
            print array[1]
            return 0

    return 0

if __name__ == "__main__":
    sys.exit( main(sys.argv) )
