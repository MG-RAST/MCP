#!/usr/bin/env python

import sys, shlex, socket
import getpass, commands, subprocess
import re

__doc__ = """
MG-RAST Control Program (MCP)
Service-action pairs available include:
"""

MCP_path = sys.argv[0]
matchObj = re.match(r'(^.*\/)', MCP_path)
MCP_dir = matchObj.group()

# Service action to user.  Each service action is listed in this dictionary as the key.
#   Service actions that have a required user and host on which they should be run have
#   this specified as the value in this dictionary.  Commands with an empty string value
#   can be run by anyone.
sa_to_user = {'memcache clear' : '',
              'nagasaki start' : 'root@berlin.mcs.anl.gov',
              'nagasaki stop'  : 'root@berlin.mcs.anl.gov',
              'upload_page start'   : 'root@berlin.mcs.anl.gov',
              'upload_page stop'    : 'root@berlin.mcs.anl.gov'}

for key in sorted(sa_to_user.iterkeys()):
  __doc__  += key + "\n"

# Run command subroutine
def run_cmd(cmd_str):
  print cmd_str
  cmd = shlex.split(str(cmd_str))
  proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  stdout, stderr = proc.communicate()
  if proc.returncode != 0:
    raise IOError("%s\n%s"%(" ".join(cmd), stderr))

  return stdout, stderr

# Worker subroutines
def memcache(action):
  if action == "clear":
    print "Clearing memcache:"
    sout, serr = run_cmd(MCP_dir+"bin/clear_memcache.pl")
    print "memcache cleared!"
  else:
    sys.stderr.write("ERROR: action '" + action + "' not available for the 'memcache' service\n");
    return 0

  return 0

def nagasaki(action):
  if action == "start":
    print "Starting nagasaki pipeline:"
    sout, serr = run_cmd("/usr/local/bin/qstart batch")
    print "nagasaki pipeline started!"
  elif action == "stop":
    print "Stopping nagasaki pipeline:"
    sout, serr = run_cmd("/usr/local/bin/qstop batch")
    print "nagasaki pipeline stopped!"
  else:
    sys.stderr.write("ERROR: action '" + action + "' not available for the 'nagasaki' service\n");
    return 0

  return 0

def upload_page(action):
  if action == "start":
    print "Turning upload page on:"
    sout, serr = run_cmd("rm -f /mcs/bio/mg-rast/prod/locks/upload.lock")
    print "upload page turned on!"
  elif action == "stop":
    print "Turning upload page off:"
    sout, serr = run_cmd("touch /mcs/bio/mg-rast/prod/locks/upload.lock")
    print "upload page turned off!"
  else:
    sys.stderr.write("ERROR: action '" + action + "' not available for the 'upload_page' service\n");
    return 0

  return 0

def main(args):
  usage = "\nUsage: MCP service action\n" + __doc__

  # Checking number of inputs.
  if len(sys.argv) != 3:
    sys.stderr.write(usage)
    sys.stderr.write("\n")
  else:
    service = sys.argv[1]
    action = sys.argv[2]

    # Checking that user has entered a valid service-action pair.
    service_action = service + " " + action
    if service_action not in sa_to_user:
      sys.stderr.write("\nERROR: service-action '" + service_action + "' not available\n" + usage)
      sys.stderr.write("\n")
      return 0

    # Checking that the command is being called by the correct user@hostname.  Otherwise, pass
    #   the command onto the appropriate machine as the appropriate user via ssh.  For the time
    #   being we're just going to call 'sudo -s', but this will change later.
    user = getpass.getuser()
    host = socket.gethostname()
    if sa_to_user[service_action] != "" and (user + "@" + host) != sa_to_user[service_action]:
      print "Handing off command to run as: " + sa_to_user[service_action]
      array = commands.getstatusoutput("sudo -s ssh " + sa_to_user[service_action] + " " + MCP_path + " " + service_action)
      print array[1]
      return 0

    # Calling the appropriate subroutine for the given service.
    if service == "memcache":
      memcache(action)
    elif service == "nagasaki":
      nagasaki(action)
    elif service == "upload_page":
      upload_page(action)
    else:
      sys.stderr.write("\nERROR: service '" + service + "' not available\n" + usage)
      return 0

    print ""

  return 0

if __name__ == "__main__":
  sys.exit( main(sys.argv) )
